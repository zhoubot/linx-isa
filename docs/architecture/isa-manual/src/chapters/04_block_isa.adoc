[[blockisa]]
== Block-structured control flow (Block Split)

[[blockisa-overview]]
=== Overview

Linx uses an explicit *block split* convention for control flow. Control-flow is defined at **basic-block**
granularity.

**Safety rule:** every architectural control-flow target (direct, conditional, indirect, call/return) MUST point at a
**block start marker**. Branching to an address that does not begin with a block start marker MUST raise an exception.
This rule is a control-flow integrity requirement. (Evidence: MAN-02)

* `BSTOP` terminates a block.
* `BSTART.*` / `C.BSTART.*` terminate the current block and begin the next one. (Evidence: MAN-01)
* A block may also be *implicitly* terminated by the next `BSTART.*` marker in the instruction stream (toolchain
  convention; some code emits an explicit `BSTOP`/`C.BSTOP` for clarity).
* An empty block is legal (header and boundary markers only, no payload instructions).
* Canonical v0.3 assembly uses typed `BSTART.<type>` forms only; legacy PAR-style shorthand is treated as a non-canonical
  alias in reconciliation tooling and is rejected by v0.3 drift gates.
* Conditional transitions use a two-step sequence:
  1. Set the block condition using `SETC.*` / `C.SETC.*`
  2. Select the next block using `BSTART.* COND, <target>`

NOTE: `FENTRY`, `FEXIT`, and `FRET.*` template blocks are also block start markers and MUST be treated as valid control-flow targets. (Evidence: MAN-03, MAN-04)

[[blockisa-forms]]
=== Block forms (coupled / decoupled / template)

The v0.3 staged profile (preserving v0.2 baseline encodings) defines **three block forms**. Toolchains and implementations MUST enforce the legality
rules in this section.

[[blockisa-forms-coupled]]
==== Coupled blocks (default scalar CFG)

Coupled blocks are the default form used for scalar control-flow graphs.

Form:

* `BSTART{.<type>}  inst*  (BSTOP | next BSTART)`

Rules:

* A coupled block begins at a block start marker and ends at `BSTOP`/`C.BSTOP` or implicitly at the next block start
  marker.
* `B.*` header descriptors MAY appear immediately after the block start marker. In coupled blocks, such descriptors
  serve as tooling metadata and MAY be treated as no-ops by scalar-only implementations unless specified
  otherwise by the platform profile.

[[blockisa-forms-decoupled]]
==== Decoupled blocks (header + out-of-line body)

Decoupled blocks split a block into:

* a **header** in the linear instruction stream, and
* a **body** located out-of-line and referenced by the header.

This form is intended for accelerator/tile execution where the block header packages execution metadata while the
actual instruction body is placed elsewhere.

*Header form (required structure):*

* A decoupled header begins with `BSTART.<type>`.
* After `BSTART.<type>`, the header stream MUST contain **only** `B.*` header descriptors (no non-`B.*`
  instructions).
* The header MUST provide exactly one `B.TEXT <label>` descriptor which defines `BodyTPC` (the body entrypoint).
* The header ends at `BSTOP`/`C.BSTOP` or implicitly at the next block start marker in the linear stream.

*Body form (required structure):*

* The body begins at `BodyTPC` (from the header's `B.TEXT`).
* The body MUST be a **linear** snippet.
* The body MUST NOT contain:
** any `BSTART.*` / `C.BSTART.*` / `HL.BSTART.*`,
** any template block (`FENTRY`/`FEXIT`/`FRET.*`/`MCOPY`/`MSET`),
** any branch/jump/call/return instruction, or any instruction that performs an architectural control transfer,
** any `B.*` header descriptor.
* The body MUST terminate at `BSTOP`/`C.BSTOP`. A body containing only `BSTOP`/`C.BSTOP` is a valid empty body.

*Header→body→return execution:*

* When a decoupled header is executed, the engine MUST execute the body at `BodyTPC` before beginning the next block
  at the header continuation address.
* On body termination (`BSTOP`/`C.BSTOP`), execution resumes at the header continuation address:
** if the header ended with `BSTOP`/`C.BSTOP`: continuation is the instruction address immediately after that stop,
** if the header ended implicitly: continuation is the address of the next block start marker in the linear stream.

*Safety rule interaction (`B.TEXT`):*

* `BodyTPC` is an **engine-internal entrypoint** and need not begin with a block start marker.
* Any *architectural* control-flow transfer to `BodyTPC` (direct/cond/ind/call/ret) is illegal and MUST raise an
  exception, identical to branching to the interior of a coupled block.

[[blockisa-forms-template]]
==== Template blocks (standalone blocks)

Template blocks are standalone blocks that execute via a *code-template generator* (see <<templates>>). They are not
wrapped by `BSTART..BSTOP`.

Rules:

* Template blocks MUST NOT appear inside `BSTART..BSTOP` coupled blocks or inside decoupled bodies.
* Template blocks MAY be targeted by architectural control flow (they are block start markers for the safety rule).

[[blockisa-exec-model]]
=== Execution model (block boundaries)

The intended execution model is block-granular:

* Instructions within a block may be implemented with out-of-order execution/commit as a microarchitectural choice.
* Block-to-block behavior is architecturally sequential: the next block begins only after the current block is
  complete.
* Implementations that issue blocks out-of-order must retire in-order with a block reorder buffer (`BROB`) and commit
  at block boundaries.
* A block may be interpreted as a variable length macro-instruction composed from 16/32/48/64-bit encodings.

This model is the motivation for explicit block delimiters and for block-local temporaries (ClockHands) whose lifetime
is bounded by the block.

[[blockisa-barg]]
=== Block Argument Register (BARG)

Blocks carry per-block architectural state called the **Block Argument Register** (**BARG**). BARG is evaluated and
committed at **block boundaries**.

In the bring-up model, BARG includes (non-exhaustive):

* the block type (e.g. `.STD`, `.SYS`, `.FP`, …),
* the selected branch/exit kind (e.g. `FALL`, `DIRECT`, `COND`, `CALL`, `IND`, `ICALL`, `RET`),
* the current predicate/condition state, and
* the selected next target (PC-relative target, or a register-based target for `RET`/`IND`-class exits).

Additional bring-up fields used by tooling and trap recovery include:

* block addresses (`BPC` / `BPCN`),
* ordering/atomic qualifiers (e.g. `AQ`/`RL` from `B.ATTR`), and
* output register mapping for split blocks.

**BARG lifetime rules (bring-up):**

* BARG is reset/initialized at block start (a block start marker).
* `SETC.*` / `C.SETC.*` update BARG and MUST execute *inside a block* (after a block start marker). `SETC` may appear
  anywhere in the block; it need not be the last instruction.
* At block commit (`BSTOP` or the next block start marker), the execution engine consults BARG and commits:
** block-to-block control flow, and
** any architectural outputs described by the block header (e.g. split-block output mapping).
* Context switches MUST preserve BARG as part of the LXCPU architectural state.

[[blockisa-block-types]]
=== Block types and branch types

`BSTART` forms encode two orthogonal concepts:

* a **block type** (e.g. `.STD`, `.SYS`, `.FP`, `.MPAR`, …), and
* a **branch type** / transition kind (e.g. `FALL`, `DIRECT`, `COND`, `CALL`, `IND`, `ICALL`, `RET`).

The bring-up profile constrains certain combinations (examples):

* `.SYS` blocks fall through only (`FALL`), optionally with a fixup label.
* `.MPAR` / `.MSEQ` blocks are described as fall-through forms used to select memory-parallel vs memory-sequential
  execution modes.
* `.FP` blocks mirror `.STD` transitions but mark a floating-point execution context.

Block types beyond the scalar core (e.g. `.TMA`, `.VPAR`, `.VSEQ`, `.CUBE`, `.FIXP`) appear in the catalog as
Block Split forms; this manual treats their detailed execution semantics as staged in v0.3 unless explicitly specified
in the golden sources (`spec/isa/golden/v0.3/`).

[[blockisa-tile]]
=== Tile blocks (TAU)

Linx defines *tile blocks* for hardware-accelerated tile operations. A tile block is a basic block that:

* starts with a typed tile/vector header (`BSTART.TMA`, `BSTART.CUBE`, `BSTART.MPAR`, `BSTART.MSEQ`,
  `BSTART.VPAR`, `BSTART.VSEQ`), and
* ends at `BSTOP` / `C.BSTOP` or the next block start marker.

Tile blocks operate on **tile registers** (see <<progmodel-tile>>), and use explicit per-block descriptors:

* `B.IOT` / `B.IOTI` describe tile inputs/outputs (including relative tile references and transfer sizing)
* `B.IOR` describes GPR inputs/outputs for the block
* `B.ARG` carries tile/tensor layout format selection for the block
* `B.DIM` / `C.B.DIM*` may be used to provide block-local dimensions and valid masks via `LB0..LB2`

Bring-up contract (strict v0.3 current profile):

* Typed block starts are canonical (`BSTART.TMA`, `BSTART.CUBE`, `BSTART.MPAR`, `BSTART.MSEQ`, `BSTART.VPAR`,
  `BSTART.VSEQ`).
* Legacy PAR-style block-start spelling is compatibility input only and MUST NOT appear in canonical outputs.
* Compatibility opcode streams carrying legacy tile-op `163` are normalized to the corresponding typed form by profile
  reconciliation tooling.
* `TLOAD`/`TSTORE`/`TPREFETCH` are the staged memory-tile baseline for AI workloads.
* `MCALL` semantics remain represented via `.MPAR`/`.MSEQ` execution modes in the staged profile.

**Immutability rule (design intent):** a tile block consumes input tiles and produces a new destination tile; it does
not mutate the input tiles in-place.

NOTE: In the strict profile contract, `B.IOTI` prints transfer size in KiB (`->t<1KB>`, `->acc<4KB>`)
and uses `last` to mark the terminal descriptor in a block header chain. Descriptor metadata may be carried by multiple
`B.IOR` and `B.IOT/B.IOTI` entries in the same header; descriptors are consumed in header order.

Bring-up v0.3 descriptor rules (normative for this bring-up profile):

* `B.IOT` / `B.IOTI` *tile references* are printed as `t#k` / `u#k` / `m#k` / `n#k` where `k` is 1-based.
  The encoded tile-id mapping is:
** `t#k` → tile-id `k-1` (0..7)
** `u#k` → tile-id `8+(k-1)` (8..15)
** `m#k` → tile-id `16+(k-1)` (16..23)
** `n#k` → tile-id `24+(k-1)` (24..31)
  These tile-ids name positions within the corresponding hand’s architectural tile-register queue.
* `B.IOTI` `SizeCode` maps to bytes as `bytes = 2^(SizeCode+4)` with strict architectural clamp to `512B..4KB`.
* `S0V` / `S1V` semantics are *inverted*: `0` means the corresponding `SrcTile*` is present as an input; `1` means absent.
  When a source is absent, its corresponding `SrcTile*` field is ignored and SHOULD be encoded as `0` in canonical v0.3 output.
* `DstTile` encodes the destination *kind* and controls where the tile-producing engine allocates the output:
** `0`: `t` hand (T queue)
** `1`: `u` hand (U queue)
** `2`: `m` hand (M queue)
** `3`: `n` hand (N queue)
** `4`: implicit accumulator (`acc`)
* For destination kinds `t/u/m/n`, the destination tile register is allocated implicitly as a **queue push**:
** the output becomes the new `hand#1` definition (for example `->u<16KB>` allocates a new `u#1`),
** existing definitions in that hand shift down (`hand#1→hand#2`, `hand#2→hand#3`, …),
** the oldest definition (`hand#8`) is evicted.
** for `B.IOTI`, the `SizeCode` updates the newly allocated (`hand#1`) tile register’s tracked byte-size.
* Input tile references (`t#k`/`u#k`/`m#k`/`n#k`) name a position in the corresponding **tile register queue**, where `k=1`
  is the most recent definition and larger `k` values refer to older definitions.
* `.reuse` is a staged hint bit carried on input operands. In this bring-up profile, it is required to disassemble and
  re-encode deterministically, but it does not change the queue indexing rules defined above.
* `MAMULB` / `MAMULB.ACC` use `SrcTile0/SrcTile1` as the two tile inputs; the output is the implicit accumulator (`->acc<...>`).
* `group=1` is used as the terminal descriptor form in bring-up streams and is rendered as `last` in disassembly.
* `B.IOR` disassembly omits zero GPR inputs/outputs and prints the input list in encoding order (`RegSrc0`, `RegSrc1`, `RegSrc2`)
  (for example, `[s0,a6],[]`).

[[blockisa-descriptors]]
=== Block header descriptors (B.* metadata)

In addition to a block start marker, a block may contain a short sequence of **block header descriptors** (`B.*`)
that define per-block metadata for accelerated/tile execution and for bring-up tooling.

Bring-up conventions:

* Block header descriptors are placed **immediately after** the block start marker.
* Block metadata is **reset at block start**; repeated descriptor writes within a block are legal, but tooling should
  prefer *single assignment* in the header.
* Scalar-only implementations may treat most descriptors as **hints/no-ops**, but accelerated implementations may
  consult them for correctness (tile operand binding, ordering, traps).

The v0.3 staged catalog includes the following descriptor families:

* **Block I/O binding**
  - `B.IOR`: binds GPR inputs/outputs for a block.
  - `B.IOT` / `B.IOTI`: binds tile inputs/outputs for a block (including optional input reuse and transfer sizing).
  - `B.IOD`: binds dependency metadata (e.g. for scheduling between producer/consumer blocks).
* **Block arguments**
  - `B.ARG`: writes a per-block layout/format selector used by TMA tile load/store pipelines.
  - `B.DIM`: writes a block argument register (`LB0`–`LB2`) used for loop bounds, dimensions, and valid masks.
* **Block attributes and hints**
  - `B.ATTR`: sets attributes such as trap/atomic/order/layout qualifiers for the current block.
  - `B.HINT`: sets performance hints (branch likelihood, temperature, prefetch sizing, trace markers).
* **Text/offset annotations**
  - `B.TEXT`: in a decoupled block header, selects the out-of-line body entrypoint (`BodyTPC`). In coupled blocks it
    MAY be used as a tooling annotation.

NOTE: Detailed semantics for tile operand binding and for attribute/hint fields are under active bring-up. This manual
specifies the *encoded contract* (see <<insnref>>) and provides bring-up guidance; implementations may initially treat
these as metadata that does not affect scalar execution unless explicitly stated by the platform profile.

[[blockisa-v03-ai]]
=== v0.3 staged AI extension rules

The v0.3 staged profile integrates only reconciled and internally consistent AI-oriented behavior:

* Canonical mnemonic policy: vector canonical forms are `V.*`; legacy raw `L.*` spellings are normalization-only input.
* Canonical block-start policy: use typed `BSTART.*` spellings in v0.3-facing disassembly/docs/tests.
* `B.IOT/B.IOTI` group scheduling is defined for staged groups 0/1; unresolved `group=2` behavior is deferred.
* `MAMULBMX*` raw material with contradictory `group=2` contracts is deferred and not part of canonical v0.3 outputs.
* Broad fixed-pipe/TCVT raw extensions are deferred from canonical v0.3 until fully reconciled.

[[blockisa-v03-pto-map]]
=== v0.3 canonical PTO-to-TAU mapping (auto-mode profile)

The canonical v0.3 auto-mode profile maps PTO tile primitives to typed TAU block headers and descriptors:

* `PTO TLOAD`:
  `BSTART.TMA(TLOAD)` + `B.DIM(LB0/LB1)` + `B.ARG` + `B.IOR*` + `B.IOT/B.IOTI`
* `PTO TSTORE`:
  `BSTART.TMA(TSTORE)` + `B.DIM(LB0/LB1)` + `B.ARG` + `B.IOR*` + `B.IOT/B.IOTI`
* `PTO TMATMUL`:
  `BSTART.CUBE(MAMULB)` (+ ACC convert/output block when needed)
* `PTO TMATMUL_ACC`:
  `BSTART.CUBE(MAMULB.ACC)` (+ ACC convert/output block when needed)

Normative notes:

* `B.ARG + B.IOR` are both required for descriptor-rich `TLOAD/TSTORE`.
* Multiple `B.IOR` and `B.IOT/B.IOTI` descriptors in one header are legal and consumed in order.
* Canonical v0.3 artifacts MUST NOT encode unresolved `group=2` behavior.

[[blockisa-simt]]
=== SIMT-style vector blocks (`MSEQ`/`MPAR`/`VSEQ`/`VPAR`)

Linx vector execution is SIMT-style: a vector block body specifies **one lane** of computation, and hardware repeats
that body across a multi-dimensional lane space defined by `LB0..LB2`.

Bring-up execution model (normative for strict v0.3):

* `LB0..LB2` are written by `B.DIM` / `C.B.DIM*` in the block header.
* Hardware exposes lane counters `lc0..lc2` to the block body; on block entry they are initialized to `0`.
* The body is executed for each lane tuple `(lc0, lc1, lc2)` with:
** `lc0` iterating fastest: `0 .. (LB0-1)`
** `lc1`: `0 .. (max(LB1,1)-1)`
** `lc2`: `0 .. (max(LB2,1)-1)`
* `MSEQ` / `VSEQ`: lanes are committed in lexicographic order (`lc0` inner-most, then `lc1`, then `lc2`).
* `MPAR` / `VPAR`: lanes are conceptually parallel; an implementation MAY commit lanes in any order, but MUST be
  observationally equivalent to some interleaving consistent with the architectural memory-order rules.
* Group interpretation for canonical 1-D lowering:
** `LB0` denotes lanes per group (`lane_count`),
** `LB1` denotes group count (`group_count`),
** the linear lane index is `lc0 + lc1 * lane_count`.
* Scalar instructions in vector bodies are **uniform per group** (one scalar-uniform lane context per group replay).

Decoupled body form (bring-up constraint):

* The header MUST contain exactly one `B.TEXT <tpc>` selecting an out-of-line **linear** body.
* The body MUST terminate at `BSTOP` / `C.BSTOP`.
* The body MUST NOT contain any `B.*` header descriptors or block start markers.

Example (2-D nested loop using `MSEQ`):

[source,asm]
----
    # for (i=0; i<n; i++)
    #   for (j=0; j<m; j++)
    #     a[i][j] = i + j

	    BSTART.MSEQ 0
	    B.TEXT .body
	    B.IOR [s0],[]          # a base pointer mapped to ri0
	    B.DIM a0, 0, ->lb0     # m
	    B.DIM a1, 0, ->lb1     # n
	    C.BSTART

.body:
	    v.add lc0, lc1.sw, ->vt
	    v.sw.brg vt#1, [ri0, lc0<<2, lc1<<10]   # example stride: 1024B = (1<<10)
	    C.BSTOP
----

[[blockisa-rdc]]
=== Vector reduction operations in SIMT bodies (`V.RD*`)

`V.RD*` operations provide lane-to-scalar reductions inside vector bodies:

* `V.RDADD`, `V.RDAND`, `V.RDOR`, `V.RDXOR`, `V.RDMIN`, `V.RDMAX`,
  `V.RDFADD`, `V.RDFMIN`, `V.RDFMAX`.
* Source operand is a vector-lane value (`vt`/`vu`/`vm`/`vn` namespace).
* Destination is a scalar destination encoding:
** block/group-local scalar state (`t/u` and profile-defined block-local scalar destinations), or
** global scalar registers (`R0..R23`) for inter-group accumulation.

Execution/ordering rules:

* `MSEQ` reductions are deterministic in lexical `LC` replay order.
* `MPAR` reductions are only valid when dependence-safe; compiler emission must require associative/commutative legality
  (or an explicit programmer parallel hint with matching semantics).
* Non-associative reductions in `MPAR` are illegal unless the profile explicitly defines the numerical relaxation.
* Strict bring-up compiler lowering of reduction live-outs MAY stage through a bridged scratch path:
  `V.RD*` to scalar destination, followed by `V.SW.BRG` to an `ri*`-bound scratch slot consumed by scalar continuation code.
* The staged lowering form requires an operation-identity initializer (`0` for add/xor/or, `-1` for and, `1` for mul when enabled).

[[blockisa-v03-bridge]]
=== Vector memory-bridge naming (strict profile)

For vector blocks, canonical bridge operands and mnemonic families are:

* `load.local` / `store.local`: tile/local direction accesses.
* `load.brg` / `store.brg`: bridged global-memory accesses.
* `ri0..rin`: ordered vector argument namespace mapped from `B.IOR`.
* `TA`, `TB`: vector input tile bases.
* `TO`: vector output tile base.
* `TS`: vector scratch tile base.

Encoding/mnemonic mapping (normative):

* `load.local` / `store.local` correspond to `V.*` memory ops with the `.local` qualifier set (the `L` bit in the
  encoding). Example families: `v.lb.local`, `v.lw.local`, `v.sb.local`, `v.sw.local`.
* `load.brg` / `store.brg` correspond to `V.*.BRG` memory ops selecting the bridged global-memory path (the `BRG`
  variant in the mnemonic). Example families: `v.lb.brg`, `v.lw.brg`, `v.sb.brg`, `v.sw.brg`.

Bring-up operand constraints (strict profile):

* `.brg` vector memory ops MUST use `ri*` as their base operand (`SrcL`); using scalar GPR names directly is illegal.
* `.local` vector memory ops MUST use tile bases (`TA/TB/TC/TD/TO/TS`) as their base operand (`SrcL`).
* `VSEQ`/`VPAR` blocks MUST NOT use `.brg` memory ops (tile-only vector execution).

Bring-up tile-base binding for `.local` ops (normative for strict v0.3):

* Tile bases are derived from the header's `B.IOT/B.IOTI` descriptors in header order:
** `TA/TB/TC/TD` map to the first four *present* source tiles across the descriptor stream (in `SrcTile0` then
   `SrcTile1` order).
** `TO/TS` map to the first two destination tiles encoded in an *absent* source slot (preferring `SrcTile1`, then
   `SrcTile0`), matching the v0.3 disassembly contract for `B.IOTI`.
* If a referenced base is not bound by the current header, the access is illegal.

Vector block bodies may mix scalar-uniform and vector instructions; scalar-uniform forms use scalar block-local state
(`GPR`, `t/u`, block-condition state), while vector forms use vector/tile-local namespaces.

Predicate and replay semantics for mixed bodies:

* `SETC.*` in the body updates the scalar block-control predicate domain (`BARG.CARG`); it does not directly mask vector lanes.
* Vector lane predicates are data values produced by `V.CMP.*`/`V.F*` compare ops and consumed by vector predicate forms
  (`V.CSEL`, and profile-defined predicated vector ops); lane predicate truth is `value != 0`.
* The body is replayed once per `LC` tuple. Scalar instructions execute on every replay iteration in program order together
  with vector instructions.
* Vector instructions MUST import scalar inputs through `B.IOR`/`ri*` (except `zero` where encoding permits). Direct scalar
  GPR operand names in `V.*` forms are illegal in strict v0.3.

[[blockisa-bcmd]]
=== Block-command lifecycle

The architectural interface between the first and second layer is a block command:

* `BSTART.<type>` begins a new command:
** packs the block opcode/type (and any type-specific info) into the command header.
** conceptually allocates a `BID` (block ID) for `BROB` tracking.
* Header descriptors pack additional command fields:
** `B.IOR`: reads input GPR values when they are ready and packs them into the command payload; reserves tags for GPR
   live-outs.
** `B.IOT`: performs tile rename, computes input/output tile base addresses, and packs those addresses into the command
   payload.
** `B.ARG` / `B.ATTR`: pack block-type-defined immediates/attributes.
** `B.IOD` (compat/obsolete): encodes dummy dependence edges for legacy streams.
** `B.DIM`: packs block dimensions (`LB0..LB2`) for SIMT/vector replay and for tile engines.
** `B.TEXT`: packs the out-of-line body `TPC` for decoupled blocks.
* `BSTOP` (or an implicit boundary at the next block start marker) finalizes the command and dispatches it to the
  selected second-layer PE.
* The PE executes only when a valid command is received; it may buffer multiple commands internally.
* On completion (or fault), the PE returns:
** live-out values (GPR writes and/or tile writes) for architectural state update, and
** a status code (success, fail, exception metadata) for `BROB`.
* `BROB` tracks completion and retires block commands in-order; speculative commands may be flushed by misprediction.

[[blockisa-tepl]]
=== Generic accelerator block (`BSTART.TEPL`)

`BSTART.TEPL` provides a generic extensible block type for implementation-defined in-core accelerators.

* `BSTART.TEPL` headers use the same descriptor families (`B.ATTR`, `B.ARG`, `B.IOR`, `B.IOT`) as other decoupled
  blocks.
* `BSTART.TEPL` blocks must follow the same block-boundary legality rules and must not directly bypass the memory and
  privilege contracts defined in this manual.

[[blockisa-assembly]]
=== Assembly/disassembly conventions

* The default block type `.STD` is omitted:
  - `BSTART` means `BSTART.STD`
  - `C.BSTART` means `C.BSTART.STD`
* For returns, a common convention is:
  - `C.BSTART RET` then `c.setc.tgt ra`

`SETC.TGT` selects a register or link target used by `RET`/`IND`-class transitions in the common convention above.
`SETRET`/`C.SETRET` materialize a return address into `ra` for call sequences.

NOTE: The bring-up profile notes that `C.BSTOP` is encoded as all-zeros in the 16-bit space; it functions both as an
invalid/reserved encoding and as the block-stop marker in current conventions.

[[blockisa-call-return]]
=== Calls, returns, and return addresses

In the current toolchain bring-up:

* Calls are represented as a block transition (`BSTART CALL, <target>`).
* The return address in `ra` is materialized using `addpc/hl.addpc` or `setret/c.setret` patterns.
* `FRET.STK` is treated as a `ret`-class encoding extension by some tooling (e.g. callgraph analysis).

**Constraint (call header pairing):**

When `SETRET`/`C.SETRET` is used to materialize the return address for a call transition, it must appear **immediately
after** the call-type block start marker (e.g. `BSTART CALL, <target>` / `C.BSTART CALL`). Tooling and hardware may
treat the `BSTART`+`SETRET` pair as a fused call header; no other instruction may be placed between them.

[[blockisa-examples]]
=== Example patterns

The following snippets are representative patterns; exact scheduling and block splitting are toolchain-dependent.

*Conditional block transition:*

[source,asm]
----
setc.ne  a0, zero
BSTART   COND, label
----

In this pattern, `SETC.*` produces a block-local condition that is consumed by `BSTART COND`. A typical interpretation
is:

* if the condition is true: branch to `label`
* otherwise: fall through to the next sequential block in the instruction stream

NOTE: With the safety rule above, `label` must refer to a block start marker (e.g. `BSTART.*` or a template block such
as `FENTRY`/`FRET.*`). Branching into the interior of another block is invalid and raises an exception.

*Direct call with explicit return address:*

[source,asm]
----
BSTART    CALL, callee
c.setret  return_label, ->ra
----
