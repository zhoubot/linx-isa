[[memory]]
== Memory operations (loads, stores, atomics)

This chapter summarizes the addressing conventions used by the scalar memory instruction families. Refer to the
instruction reference for the full set of encodings and per-form notes.

[[memory-model]]
=== Memory model and ordering (v0.3 staged, v0.2 baseline preserved)

Linx uses a **weakly ordered** memory model suitable for out-of-order
implementations. The ordering contract is expressed in Linx terms:

* A **memory operation** is a load, store, atomic read-modify-write, or fence.
* **Program order** is the architectural order of committed memory operations
  on a single LXCPU.
* A **device/MMIO** access is any access to regions defined by the platform
  as device memory (including UART-style MMIO used by bring-up).

Unless a platform profile tightens the rules, the staged v0.3 contract is:

* Plain loads/stores are **Relaxed** with respect to other addresses.
* For a single aligned location in **Normal** memory, writes participate in a
  coherent per-location order (software may rely on per-location coherence).
* Ordering across different locations requires either:
  - an atomic operation with `.aq`/`.rl` qualifiers, or
  - an explicit fence (`FENCE.D` / `FENCE.I`).

NOTE: This chapter defines the architectural contract in a style similar to Arm
barrier definitions, but using Linx terms (LXCPU, commit, and the Block ISA
execution model). A platform profile MAY define stronger ordering for
performance or compatibility.

[[memory-channels]]
=== BCC and MTC channels (v0.3 staged)

v0.3 staged bring-up explicitly models two architectural memory issue channels:

* **BCC channel**: scalar `load/store/atomic/fence` operations and ordering point for scalar blocks.
* **MTC channel**: tile-oriented memory blocks (`TLOAD`, `TSTORE`, `TPREFETCH`) and staged MCALL-like memory mode.

Staged rules:

* In normal tile mode, BCC and MTC requests share one architectural ordering contract (`Program order` + fences/aq/rl).
* Entering MCALL-like mode requires an acquire-style boundary before MTC-only execution begins.
* Exiting MCALL-like mode requires a release-style boundary before subsequent scalar blocks execute.
* While MCALL-like mode is active, scalar memory issue is architecturally closed for correctness.

[[memory-tload-tstore]]
=== TLOAD/TSTORE staged semantics

`TLOAD` and `TSTORE` are template-style tile memory operations. The staged architectural model is:

* Address footprint is 2D and derived from base/stride/dimension state (`RegSrc0`, `RegSrc1`, `LB0/LB1`).
* A single `TLOAD`/`TSTORE` may decompose into multiple internal memory beats; completion is not atomic to observers.
* Internal beats of one operation are not guaranteed to issue in source-program order.
* Unaligned shared-memory access is allowed in staged profile unless tightened by platform policy.
* Group-overlap contracts that are unresolved in raw v0.3 material are deferred from canonical spec behavior.

[[memory-mcall]]
=== MCALL staged semantics

MCALL-like behavior remains staged through `.MPAR/.MSEQ` execution modes:

* Execution is non-speculative until declared input dependencies (`B.IOT`/`B.IOD`) are resolved.
* Prior side-effecting tile stores must be globally ordered before MCALL-like execution starts.
* Detailed VREG-only local register semantics from raw notes are deferred until fully reconciled.

[[memory-types]]
==== Memory types (Normal vs Device)

Linx platforms classify memory addresses into types. This v0.3 staged manual uses two
high-level types:

* **Normal**: cacheable memory used for code and data (SRAM/DRAM).
* **Device/MMIO**: strongly ordered, side-effecting regions used to communicate
  with devices (UART-style MMIO, interrupt controllers, etc.).

If a platform exposes additional subtypes (e.g. non-cacheable Normal, write
combining, etc.), it MUST specify how they map onto the `FENCE.D` classes (`R`,
`W`, `O`) and what extra ordering they guarantee.

[[memory-observability]]
==== Observability and order (informal model)

For bring-up, it is useful to reason about *when* a memory operation can be
observed by other agents (other LXCPUs or devices):

* A memory operation is **committed** when it becomes architecturally visible
  on the issuing LXCPU (i.e. it is past the point where a precise exception
  could cancel it).
* A memory operation is **observed** by another agent when the effects become
  visible to that agent (e.g. a load reads a value written by another LXCPU, or
  a device sees an MMIO write).

The memory model constrains the relative order of **observations** implied by
program order and by fences/atomics. It does not require a specific
micro-architecture (OOO vs in-order).

[[memory-atomics-ordering]]
==== Atomic qualifiers (`.aq` / `.rl` / `.aqrl`)

Many atomic instruction families accept ordering qualifiers:

* `.aq` (**acquire**) orders the atomic operation before subsequent loads/stores
  (and subsequent atomics) in program order on the same LXCPU.
* `.rl` (**release**) orders prior loads/stores (and prior atomics) before the
  atomic operation in program order on the same LXCPU.
* `.aqrl` combines acquire and release ordering.

NOTE: These qualifiers define the **architectural** ordering contract. A micro-
architecture may implement stronger ordering, but software MUST NOT rely on
stronger behavior unless the platform profile states so.

[[memory-endianness]]
=== Endianness and alignment

The v0.3 staged Linx toolchain and emulator model are **little-endian**: the least-significant byte of a multi-byte value is
stored at the lowest address.

Alignment rules are profile-defined. Unless a profile explicitly enables split/misaligned accesses, software should
assume that misaligned loads/stores MAY raise an exception.

[[memory-addressing]]
=== Addressing conventions

Many load/store forms use one of two base addressing styles:

* *Register-offset:* `[Base, Index<type><<shamt>]`
* *Immediate-offset:* `[Base, imm]` (scaled or unscaled depending on the mnemonic family)

The bring-up profile describes common register-offset semantics as:

* `addr = Base + (Index << shamt)`

Some mnemonics use *fixed* scaling implied by the access width (byte/halfword/word/dword), while others expose explicit
`shamt` fields.

[[memory-srcRtype]]
=== `SrcRType` (`.sw` / `.uw` / `.neg`)

Some register-offset forms annotate the index operand with a suffix that affects how the index value is interpreted:

* `.sw`: treat as signed word
* `.uw`: treat as unsigned word
* `.neg`: treat as negated (used by some ALU/compound forms)

These suffixes are part of the assembly syntax and correspond to encoded fields in certain instruction formats.

[[memory-scaled-immediates]]
=== Scaled vs unscaled immediates

Several immediate-offset families encode an immediate that is implicitly scaled by the access size:

* byte: scale 1 (`<< 0`)
* halfword: scale 2 (`<< 1`)
* word: scale 4 (`<< 2`)
* doubleword: scale 8 (`<< 3`)

Unscaled variants are typically spelled with a `.U` suffix (e.g. `LWI.U`, `LDI.U`) and use the immediate value in
bytes without the implicit shift.

[[memory-pcrel]]
=== PC-relative loads/stores

The catalog includes `*.PCR` forms that compute an address relative to the current PC/TPC (as defined by the draft).
These forms are used by toolchains for efficient access to nearby constants and for position-independent code patterns.

[[memory-atomics]]
=== Atomics (overview)

The v0.3 staged catalog includes load-reserved/store-conditional (`LR.*`/`SC.*`) and read-modify-write style atomic operations
with qualifier suffixes (e.g. `.aq`, `.rl`). The precise memory ordering semantics are defined by the ISA draft
(`isa/golden/v0.3/`) and the architectural model implemented by the toolchain/QEMU/RTL.

Bring-up model (ordering qualifiers):

* `.aq` (*acquire*): prevents later loads/stores from being observed before the atomic operation.
* `.rl` (*release*): prevents earlier loads/stores from being observed after the atomic operation.
* `.aqrl`: combines acquire and release.

In Arm-like terms, `.aq` is analogous to an acquire barrier on the same LXCPU,
and `.rl` is analogous to a release barrier.

Scope: unless a platform profile states otherwise, `.aq/.rl` apply to **Normal**
memory ordering; ordering with respect to **Device/MMIO** requires selecting
`O` in `FENCE.D` (or using platform-defined stronger rules).

[[memory-fences]]
=== Fences

The v0.3 staged catalog defines two fence instructions:

* `FENCE.D pred_imm, succ_imm`: orders memory operations.
* `FENCE.I`: synchronizes instruction fetch with prior data stores (self-modifying code / I-cache coherence boundary).

[[memory-fence-d]]
==== `FENCE.D pred_imm, succ_imm`

`pred_imm` and `succ_imm` are **bitmaps** selecting classes of operations.

Bring-up definition (v0.3 staged):

* Bit 0 (`R`): normal memory reads
* Bit 1 (`W`): normal memory writes
* Bit 2 (`O`): device/MMIO accesses
* Bit 3 (`I`): instruction-fetch visibility (see `FENCE.I`)

Semantics (v0.3 staged):

* `FENCE.D` orders all prior operations selected by `pred_imm` before all later
  operations selected by `succ_imm` in program order on the same LXCPU.
* If `O` is selected, `FENCE.D` orders device/MMIO accesses with respect to
  normal memory operations.
* If `I` is selected, `FENCE.D` additionally provides the instruction-fetch
  visibility ordering of `FENCE.I`.

Bring-up rule (cumulative visibility):

* `FENCE.D` is **cumulative**: if an LXCPU observes a write from another agent
  before the fence, then after the fence it MUST not observe later operations
  (selected by `succ_imm`) as if they occurred before that write. This matches
  the intent of an Arm-style `DMB` barrier for the selected operation classes.

Recommended usage patterns:

* Release: use either `.rl` on the publishing atomic OR `FENCE.D W,RW` (where
  `RW` means `R|W`) before publishing a flag.
* Acquire: use either `.aq` on the consuming atomic OR `FENCE.D RW,R` after
  observing the flag.
* MMIO ordering: include `O` in `pred_imm` and/or `succ_imm` when ordering
  device accesses against Normal memory (e.g. `FENCE.D O,RW`).

[[memory-fence-i]]
==== `FENCE.I`

`FENCE.I` is the architectural boundary for self-modifying code and runtime code
generation. After `FENCE.I`, instruction fetch MUST observe any prior committed
stores from the same LXCPU to memory that may be executed as instructions.

In Arm-like terms, `FENCE.I` is analogous to an instruction-synchronization
barrier for the issuing LXCPU (comparable to `ISB`) with the additional
requirement that prior stores that modify executable code become visible to
instruction fetch after the fence.
