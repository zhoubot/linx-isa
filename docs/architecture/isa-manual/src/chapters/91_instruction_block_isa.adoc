// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: 2026 Linx ISA contributors
//
// This file provides Block ISA interaction guidance for instruction groups.
// Include this after instruction_reference.adoc in the manual.

[[insnref-block-isa-guidance]]
=== Block ISA Interaction Guidelines

This section provides normative guidance on how each instruction group interacts with the Linx Block ISA.

[IMPORTANT]
====
All instructions MUST comply with the Block ISA safety rule: every architectural control-flow target MUST point at a block start marker. Branching to an address that does not begin with a block start marker MUST raise an exception. (Evidence: MAN-02)
====

==== Execution Control Instructions

Instructions: `ACRC`, `ACRE`, `ASSERT`, `BSE`, `BWE`, `BWI`, `BWT`, `EBREAK`, `FENCE.D`, `FENCE.I`

Block ISA interaction:

* `ACRC`: System-call request. MUST be the last instruction in its block. Triggers synchronous exception.
* `ACRE`: ACR enter request. MUST be the last instruction in its block. Triggers privilege transition at block commit.
* `ASSERT`: Assertion trap. Raises exception if `SrcL == 0`.
* `BSE`/`BWE`/`BWI`/`BWT`: Write-back enable/disable for tile/vector operations. Valid inside blocks.
* `EBREAK`: Breakpoint exception. Raises exception with `imm4` payload.
* `FENCE.D`: Data memory fence. Orders memory operations within the block.
* `FENCE.I`: Instruction fence. Invalidates instruction cache entries within the block.

==== Arithmetic Instructions (64-bit and 32-bit)

Instructions: `ADD`, `ADDI`, `AND`, `ANDI`, `OR`, `ORI`, `SUB`, `SUBI`, `XOR`, `XORI`, `SLL`, `SLLI`, `SRA`, `SRAI`, `SRL`, `SRLI`, and their `W` (word) variants, plus `HL.*` forms

Block ISA interaction:

* These are standard ALU operations and are valid anywhere inside a block.
* Results MAY be written to architectural destination registers (`->Rd`) or ClockHands queues (`->t`/`->u`).
* No control-flow semantics; do not affect block boundaries.

==== Load/Store Instructions

Instructions: `LDL`, `SDL`, `LDI`, `SDI`, `LBI`, `SBI`, `LWI`, `SWI`, `LHL`, `SHL`, `LDW`, `SDW`, and their `U` (unsigned) variants, plus `HL.*` PC-relative forms

Block ISA interaction:

* Standard memory operations are valid anywhere inside a block.
* Pre/post-index forms update base registers within the block; these updates are committed at block boundary.
* Misaligned accesses: behavior is implementation-defined; platforms SHOULD specify whether misaligned access traps or is handled transparently.

==== Branch Instructions

Instructions: `B.EQ`, `B.NE`, `B.GE`, `B.LT`, `B.GEU`, `B.LTU`, `B.Z`, `B.NZ`, `J`, `JR`

Block ISA interaction:

* These instructions use the two-step convention:
  1. `SETC.*` / `C.SETC.*` sets the block condition (inside the block)
  2. `BSTART.* COND, <target>` commits the conditional branch (block boundary)
* Branch targets MUST be block start markers (safety rule).
* `J` and `JR` are unconditional jumps; `JR` uses register-based target.

==== Block Marker Instructions

Instructions: `BSTART`, `C.BSTART`, `BSTOP`, `C.BSTOP`, `BSTART.*` variants, `HL.BSTART.*` variants

Block ISA interaction:

* These ARE block start markers or block terminators.
* `BSTART.*` / `C.BSTART.*`: Begin a new block; terminate the previous block.
* `BSTOP` / `C.BSTOP`: Explicitly terminate the current block.
* See <<blockisa>> for full block form definitions (coupled, decoupled, template).

==== Frame Template Instructions

Instructions: `FENTRY`, `FEXIT`, `FRET.RA`, `FRET.STK`

Block ISA interaction:

* Template blocks are STANDALONE blocks (Evidence: MAN-04).
* MUST NOT appear inside `BSTART..BSTOP` coupled blocks or inside decoupled bodies.
* Are valid architectural control-flow targets (safety rule applies).
* Encode register save/restore and stack adjustment in a single architectural operation.

==== Compare and Condition Instructions

Instructions: `CMP.EQ`, `CMP.NE`, `CMP.GE`, `CMP.LT`, `CMP.GEU`, `CMP.LTU`, `CMP.AND`, `CMP.OR`, `SETC.EQ`, `SETC.NE`, `SETC.LT`, `SETC.GE`, `SETC.LTU`, `SETC.GEU`, and their immediate variants

Block ISA interaction:

* `CMP.*`: Compare instructions that write results (used for predicated execution).
* `SETC.*`: Block condition setters. MUST execute inside a block (after a block start marker).
* `SETC.*` updates BARG state but does not itself transfer control.
* Call/return convention: `BSTART CALL` and `SETRET` MUST be adjacent with no instruction between them (Evidence: MAN-07).

==== Block Argument and Attribute Instructions

Instructions: `B.ARG`, `B.ATTR`, `B.DIM`, `B.HINT`, `B.IOD`, `B.IOR`, `B.IOT`, `B.IOTI`, `B.TEXT`

Block ISA interaction:

* These are block header descriptors and MUST appear only inside block headers (after `BSTART.*`).
* `B.TEXT`: Required in decoupled block headers to specify body entrypoint.
* `B.DIM`: Sets loop-bound registers (LB0, LB1, LB2) for tile/vector operations.
* `B.ATTR`: Sets full block-attribute fields `{C, DR, DataLayout, DataType, PadValue, T, aq, atom, far, rl}`.
* `B.HINT`: Optimization hints for the execution engine.
* `B.IOD`: Deprecated in strict-v0.3 canonical streams (compatibility input only).
* `B.IOR`/`B.IOT`/`B.IOTI`: Tile block input/output descriptors (`B.IOT` is dynamic-size via `RegSrc`; `B.IOTI` is
  immediate-size via `SizeCode`).

==== Floating-Point Instructions

Instructions: `FADD`, `FSUB`, `FMUL`, `FDIV`, `FSQRT`, `FMADD`, `FMSUB`, `FNMADD`, `FNMSUB`, `FCVT`, `FCVTA`, `FCVTM`, `FCVTN`, `FCVTP`, `FCVTZ`, `FABS`, `FMAX`, `FMIN`, `FEQ`, `FNE`, `FLT`, `FGE`, and their sized variants

Block ISA interaction:

* Standard floating-point operations are valid anywhere inside a block.
* No special Block ISA semantics; behave like ALU operations for control-flow purposes.
* Floating-point exceptions do not raise traps in v0.3; they update sticky status registers (e.g., `FFLAGS`).

==== Tile and Vector Instructions (v0.3)

Instructions: `BSTART.TLOAD`, `BSTART.TSTORE`, `BSTART.TMOV`, `BSTART.TMATMUL`, `BSTART.TMATMUL.ACC`, `BSTART.ACCCVT`,
`BSTART.TMA`, `BSTART.CUBE`, `BSTART.TEPL`, `BSTART.VPAR`, `BSTART.VSEQ`, `BSTART.MPAR`, `BSTART.MSEQ`, `TLOAD`,
`TSTORE`, `TMOV`, `MAMULB`, `TCVT`, and related forms

Block ISA interaction:

* Tile/vector blocks use decoupled form with header + out-of-line body.
* Headers contain `BSTART.<type>` followed by `B.*` descriptors including `B.TEXT` for body pointer.
* Alias/encoding split is strict:
  - `BSTART.TLOAD/TSTORE/TMOV` map to `BSTART.TMA Function=0/1/2`.
  - `BSTART.TMATMUL/TMATMUL.ACC/ACCCVT` map to `BSTART.CUBE Function=0/2/8`.
  - `BSTART.TADD/TSUB/TROWMAX/...` map to `BSTART.TEPL TileOp10=<op code>`.
* Strict-v0.3 `DataType` mapping (u5):
  - floating: `FP64=0`, `FP32=1`, `FP16=2`, `FP8=3`, `BF16=6`, `FPL8=7`, `FP4=11`, `FPL4=12`.
  - signed integer: `INT64=16`, `INT32=17`, `INT16=18`, `INT8=19`, `INT4=20`.
  - unsigned integer: `UINT64=24`, `UINT32=25`, `UINT16=26`, `UINT8=27`, `UINT4=28`.
* `BSTART.TLOAD/TSTORE` are header-only tile-memory commands and require `B.ARG` (layout/pad) + `B.IOR` (stride/base) +
  `B.IOT/B.IOTI` (tile binding/size).
* `B.IOT/B.IOTI` are the canonical tile-binding descriptors for all strict-v0.3 tile blocks.
* `BSTART.TMATMUL/TMATMUL.ACC` are header-only CUBE commands and require `B.DIM` (`LB0/LB1/LB2` as `m/n/k`) +
  `B.IOT/B.IOTI` tile bindings.
* `BSTART.TMATMUL/TMATMUL.ACC` write singleton implicit ACC state (`TMATMUL` seeds, `TMATMUL.ACC` accumulates);
  strict-v0.3 does not encode an explicit ACC tile id.
* `BSTART.ACCCVT` is a header-only CUBE command and requires quantization arguments via `B.ARG` + `B.IOR`
  (scale/zero-point required).
* `BSTART.ACCCVT` consumes implicit ACC and writes tile destination metadata via `B.IOT/B.IOTI`; no ACC source id is encoded.
* Required strict chain is `TMATMUL` -> `TMATMUL.ACC` (optional repeats) -> `ACCCVT` before tile materialization.
* Tile-byte legality is fail-fast with
  `tile_bytes = ceil(dim0*dim1*dim2*elem_bits/8)` (`dim2=1` when absent); `elem_bits` comes from `DataType`.
* `BSTART.TEPL` carries PTO template-op selection in `TileOp10`; strict-v0.3 TEPL template blocks are header-driven
  (no SIMT body).
* `TVEC` is not a strict-v0.3 block header mnemonic; use `BSTART.VPAR`/`BSTART.VSEQ`.
* Historical `MCALL` naming remains applicable as legacy text, but strict-v0.3 executable forms are `BSTART.MPAR` and
  `BSTART.MSEQ`.
* `BSTART.VPAR/VSEQ` are TVEC-equivalent forms and require `B.TEXT` + SIMT body.
* Bodies (when present) MUST be linear (no branches, calls, returns, or block markers) and terminate at `BSTOP`.
* See <<blockisa-forms-decoupled>> for complete rules.

==== PC-Relative Instructions

Instructions: `ADDTPC`, `HL.ADDTPC`, `SETRET`, `HL.SETRET`

Block ISA interaction:

* `ADDTPC`: PC-relative add; writes result without control-flow transfer.
* `SETRET`: Return address materialization. MUST appear immediately after `BSTART CALL` (adjacency rule).
* PC-relative offsets are halfword-scaled: `target = TPC + (imm << 1)`.
