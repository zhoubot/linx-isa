# Linx LLVM/Clang toolchain (bring-up)

This folder tracks the LLVM/Clang toolchain bring-up for **LinxISA** (Linx Instruction Set Architecture).

- Official ISA name: **LinxISA**
- Short name: **Linx**

## Targets / triples

- `-target linx64-linx-none-elf` (LP64-style datalayout)
- `-target linx32-linx-none-elf` (ILP32-style datalayout)

The LLVM arch names are `linx64` and `linx32` (e.g. `linx64-linx-none-elf`).

## Build (llvm-project)

This repo expects an LLVM build configured with:

- `LLVM_ENABLE_PROJECTS=clang`
- `LLVM_EXPERIMENTAL_TARGETS_TO_BUILD=LinxISA`
- `LLVM_TARGETS_TO_BUILD=AArch64` (host convenience; can be broader)

Example build dir used in this workspace:

- `~/llvm-project/build-linxisa-clang`

Build:

```bash
cmake --build ~/llvm-project/build-linxisa-clang --target clang llc llvm-objdump llvm-objcopy llvm-readobj -j 12
```

## What codegen emits (Block ISA + ClockHands)

The backend emits **BlockISA markers** and uses **ClockHands-style relative temporaries**:

- Every MachineBasicBlock starts with a block marker:
  - `C.BSTART` (STD, FALL) for the common case
  - `C.BSTART COND/DIRECT, <target>` for 16-bit PC-relative forms
  - `BSTART CALL, <target>` for direct calls
  - `C.BSTART RET/IND/ICALL` for control-flow without a PC-relative target
- **Safety:** every control-flow target must point to a block start marker (a `BSTART.*`/`C.BSTART.*`/`HL.BSTART.*`
  header or a template block). Codegen must not branch into the interior of another block.
- Printed assembly omits the default block type `.STD` (`BSTART`/`C.BSTART` are shorthand for `*.STD`).
- A block ends either with an explicit `C.BSTOP` or is implicitly terminated by the next `BSTART.*`.
- Conditional block transitions use `SETC.*` / `C.SETC.*` to set the condition, then `BSTART.* COND, <target>` to
  select the next block.
- `SETC.*` is a block-internal commit-argument update and must appear *inside a block* (after a block start marker).
- PC-relative block targets are halfword-scaled: `target = PC + (simm<<1)`.
- Single-def/single-use locals inside a block may be rewritten to T-hand form:
  - def: `->t`
  - use: `t#1..t#4` (relative to recent defs)
- Some locals may also be rewritten to U-hand form:
  - def: `->u` (U-hand push; explicit)
  - use: `u#1..u#4` (relative to recent defs)

It also emits **48-bit** immediates via `hl.lui` for 32-bit constant materialization when profitable/needed.

To shrink code size for global/constant-pool accesses, the backend folds
`ADDTPC + ADDI + (LDI/LWI/...)` back into a single PC-relative load/store where
possible:

- Loads: `lb.pcr/lh.pcr/lw.pcr/ld.pcr` (and zero-ext variants)
- Stores: `sb.pcr/sh.pcr/sw.pcr/sd.pcr`

## Template blocks

Certain macro forms (e.g. `FENTRY`/`FEXIT`/`FRET.*`) are treated as **standalone blocks** and must not be merged with
adjacent non-template instructions. These map to special hardware acceleration in the LinxCPU. Future work may extend
this model to other macro blocks (e.g. `MCOPY`, `MSET`, exception save/restore templates).

## Tests (C â†’ .s/.o/.bin)

The compile tests live in `impl/compiler/llvm/tests` and generate:

- `.s` (for inspection)
- `.o` (ELF object)
- `.bin` (raw `.text` extraction via `llvm-objcopy`)
- `.objdump` / `.relocs`

Run (linx64):

```bash
CLANG=~/llvm-project/build-linxisa-clang/bin/clang ./impl/compiler/llvm/tests/run.sh
```

Run (linx32):

```bash
CLANG=~/llvm-project/build-linxisa-clang/bin/clang TARGET=linx32-linx-none-elf OUT_DIR=./impl/compiler/llvm/tests/out-linx32 ./impl/compiler/llvm/tests/run.sh
```

## Known limitations (current bring-up)

- The **MC asm parser** is bring-up quality; some convenience syntax and some
  pseudo-instructions may not be accepted yet.
- The compile-test runner links a standalone `.elf` to resolve relocations before extracting a raw `.bin`; `.o`
  artifacts may still contain relocations by design.
- 64-bit instruction encodings in the spec (`V.*`) are vector forms and are not yet generated by the scalar C backend.
