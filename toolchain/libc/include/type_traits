// Minimal <type_traits> for the LinxISA freestanding toolchain.
//
// The Linx bare-metal target does not currently ship a full C++ standard
// library. For bring-up, we provide the small subset of <type_traits> that is
// needed by the PTO-ISA headers used in regression tests.

#ifndef LINX_TOOLCHAIN_TYPE_TRAITS_H
#define LINX_TOOLCHAIN_TYPE_TRAITS_H

#include <stddef.h>

namespace std {

using ::size_t;

template <typename T, T v>
struct integral_constant {
    static constexpr T value = v;
    using value_type = T;
    using type = integral_constant;
    constexpr operator value_type() const noexcept { return value; }
};

using true_type = integral_constant<bool, true>;
using false_type = integral_constant<bool, false>;

template <bool B, typename T = void>
struct enable_if {};

template <typename T>
struct enable_if<true, T> {
    using type = T;
};

template <bool B, typename T = void>
using enable_if_t = typename enable_if<B, T>::type;

template <typename T, typename U>
struct is_same : false_type {};

template <typename T>
struct is_same<T, T> : true_type {};

template <typename T, typename U>
inline constexpr bool is_same_v = is_same<T, U>::value;

template <typename T>
struct is_pointer : false_type {};

template <typename T>
struct is_pointer<T *> : true_type {};

template <typename T>
inline constexpr bool is_pointer_v = is_pointer<T>::value;

template <typename T>
struct is_array : false_type {};

template <typename T, ::size_t N>
struct is_array<T[N]> : true_type {};

template <typename T>
struct is_array<T[]> : true_type {};

template <typename T>
inline constexpr bool is_array_v = is_array<T>::value;

} // namespace std

#endif

